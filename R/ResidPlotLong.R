#' Efficiently examine multiple model fits
#'
#' This function is essentially a wrapper for a few \code{\link[DHARMa]{DHARMa}} functions that allow users to assess model
#' fit for models produced using \code{\link[glmmTMB]{glmmTMB}} with or without random effects.
#'
#' @param Data The unquoted name of the data frame or data table containing the raw data models are based on.
#' 
#' @param CountCol A character string specifying the name of the vector containing count data.
#' 
#' @param GroupCol A character string specifying the name of the vector containing group information (e.g., order, species) for each observation.
#'
#' @param Nsims A number indicating the number of data simulations to run with \code{\link[stats]{simulate}}.
#'
#' @param ModNames A character vector of model object names to assess model fit for.
#'
#' @param GroupPat A quoted regular expression that can be used to extract the character string representing
#' the column name containing the response variable of a model for (e.g., if the models "EpfuNb2" and "MyluNb2" are supplied for
#' the \code{ModNames} argument, an appropriate regular expression would be "^[[:alpha:]]\{4\}" because the response
#' variable columns are "Epfu" and "Mylu", respectively).
#' 
#' @param Looped A Boolean value indicating whether models were generated using a for loop or
#' apply function that results in the "Data" value in the model output including an iterative subset. 
#' Defaults to "T".
#'
#' @param TestVals A Boolean value indicating whether model fit test values should be generated alongside
#' the plots this function creates.
#'
#' @return This function outputs the plots generated by \code{\link[DHARMa]{testResiduals}}. Each resultant plot is named with
#' the model name followed by "SimResidPlot" (e.g., the plot associated with a model named "EpfuNb2" would be named
#' "EpfuNb2SimResidPlot"). If \code{TestVals = T}, test values will also be generated. The resultant test values
#' are named with the model name follow by "ResidTests" (e.g., the test values associated with a model named
#' "EpfuNb2" would be named "EpfuNb2SimResidPlot").
#'
#' @seealso \code{\link{ResidPlotWide}}
#'
#' @examples
#' data("BatDataLong", "EpfuNb2Long", "MyevNb2Long", package = "EcoCountHelper")
#' 
#' ResidPlotLong(BatDataLong, "Count", "Species",
#'  c("EpfuNb2Long", "MyevNb2Long"), "^[[:alpha:]]{4}")
#' 
#' EpfuNb2ResidTests
#' EpfuNb2SimResidPlot
#' MyevNb2ResidTests
#' MyevNb2SimResidPlot
#'
#' @export

ResidPlotLong <- function(Data, CountCol, GroupCol, ModNames, GroupPat = "^[[:alnum:]]+",
                          Looped = T, Nsims = 1000, TestVals = T){
  
  ResidPlotterSub <- function(GroupMod){
    TmpMod <- get(Filter(function(x) inherits(get(x), "glmmTMB"), ls(pattern = GroupMod,
                                                                     pos = .GlobalEnv)), pos = .GlobalEnv)
    
    Group <- regmatches(GroupMod, regexpr(GroupPat, GroupMod))
    TmpFull <- Data[Data[[GroupCol]] == Group,]
    
    if(Looped == T){
      TmpMod <- stats::update(TmpMod, data = TmpFull)
    }
    
    
    ModTab <- stats::simulate(TmpMod, nsim = Nsims)
    SimMod <- do.call(cbind, ModTab)
    
    SimModDharma <- DHARMa::createDHARMa(simulatedResponse = SimMod, observedResponse = TmpFull[[CountCol]],
                                 fittedPredictedResponse = predict(TmpMod), integerResponse = TRUE)
    GroupResidTests <- DHARMa::testResiduals(SimModDharma)
    
    title(sub = GroupMod, font.sub = 2)
    ResidPlot <- grDevices::recordPlot()
    assign(paste0(GroupMod, "SimResidPlot"), ResidPlot, pos = .GlobalEnv)
    if(TestVals == T){assign(paste0(GroupMod, "ResidTests"), GroupResidTests, pos = .GlobalEnv)}
  }
  lapply(ModNames, ResidPlotterSub)
}
