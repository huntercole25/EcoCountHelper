#' Efficiently examine multiple model fits
#'
#' This function is essentially a wrapper for a few \code{\link[DHARMa]{DHARMa}} functions that allow users to assess model
#' fit for models produced using \code{\link[glmmTMB]{glmmTMB}} with or without random effects.
#'
#' @param Data The unquoted name of the data frame or data table containing the raw data models are based on.
#'
#' @param Nsims A number indicating the number of data simulations to run with \code{\link[stats]{simulate}}.
#'
#' @param ModNames A character vector of model object names to assess model fit for.
#'
#' @param GroupPat A quoted regular expression that can be used to extract the character string representing
#' the column name containing the response variable of a model for (e.g., if the models "EpfuNb2" and "MyluNb2" are supplied for
#' the \code{ModNames} argument, an appropriate regular expression would be "^[[:alpha:]]\{4\}" because the response
#' variable columns are "Epfu" and "Mylu", respectively).
#'
#' @param TestVals A Boolean value indicating whether model fit test values should be generated alongside
#' the plots this function creates.
#'
#' @return This function outputs the plots generated by \code{\link[DHARMa]{testResiduals}} with a label
#' indicating the model they came from on the bottom of the plots. Each resultant plot is named with
#' the model name followed by "SimResidPlot" (e.g., the plot associated with a model named "EpfuNb2" would be named
#' "EpfuNb2SimResidPlot"). If \code{TestVals = T}, test values will also be generated. The resultant test values
#' are named with the model name follow by "ResidTests" (e.g., the test valuesassociated with a model named
#' "EpfuNb2" would be named "EpfuNb2SimResidPlot").
#'
#' @section Details:
#' It is important to note that if a custom-written function is used to manipulate data in any models (e.g.,
#' if a user-written function is used to scale by two standard deciations instead of one as
#' \code{\link[base]{scale}} does), that function must be defined in your global environment.
#'
#' @examples
#' data("BatData", "EpfuNb2", "MyevNb2", package = "ModelHelper")
#' scale2 <- function(x){(x - mean(x))/(2*sd(x))}
#' ResidPlotter(BatData, "^[[:alpha:]]{4}", c("EpfuNb2", "MyevNb2"))
#'
#' @export

ResidPlotter <- function(Data, GroupPat, ModNames, Nsims = 1000, TestVals = T){

  ResidPlotterSub <- function(GroupMod){
    TmpMod <- get(Filter(function(x) inherits(get(x), "glmmTMB"), ls(pattern = GroupMod,
                                                                     pos = .GlobalEnv)), pos = .GlobalEnv)
    Group <- regmatches(GroupMod, regexpr(GroupPat, GroupMod))

    ModTab <- simulate(TmpMod, nsim = Nsims)
    SimMod <- do.call(cbind, ModTab)
    SimModDharma <- createDHARMa(simulatedResponse = SimMod, observedResponse = Data[[Group]],
                                 fittedPredictedResponse = predict(TmpMod), integerResponse = TRUE)
    GroupResidTests <- testResiduals(SimModDharma)

    title(sub = GroupMod, font.sub = 2)
    ResidPlot <- recordPlot()
    assign(paste0(GroupMod, "SimResidPlot"), ResidPlot, pos = .GlobalEnv)
    if(TestVals == T){assign(paste0(GroupMod, "ResidTests"), GroupResidTests, pos = .GlobalEnv)}
  }
  lapply(ModNames, ResidPlotterSub)
}
