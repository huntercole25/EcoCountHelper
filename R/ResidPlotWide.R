#' Efficiently examine multiple model fits
#'
#' This function is essentially a wrapper for a few \code{\link[DHARMa]{DHARMa}} functions that allow users to assess model
#' fit for models produced using \code{\link[glmmTMB]{glmmTMB}} with or without random effects.
#'
#' @param Data The unquoted name of the data frame or data table containing the raw data models are based on.
#'
#' @param Nsims A number indicating the number of data simulations to run with \code{\link[stats]{simulate}}.
#'
#' @param ModNames A character vector of model object names to assess model fit for.
#'
#' @param GroupPat A quoted regular expression that can be used to extract the character string representing
#' the column name containing the response variable of a model for (e.g., if the models "EpfuNb2" and "MyluNb2" are supplied for
#' the \code{ModNames} argument, an appropriate regular expression would be "^[[:alpha:]]\{4\}" because the response
#' variable columns are "Epfu" and "Mylu", respectively).
#'
#' @param TestVals A Boolean value indicating whether model fit test values should be generated alongside
#' the plots this function creates.
#'
#' @return This function outputs the plots generated by \code{\link[DHARMa]{testResiduals}}. Each resultant plot is named with
#' the model name followed by "SimResidPlot" (e.g., the plot associated with a model named "EpfuNb2" would be named
#' "EpfuNb2SimResidPlot"). If \code{TestVals = T}, test values will also be generated. The resultant test values
#' are named with the model name follow by "ResidTests" (e.g., the test values associated with a model named
#' "EpfuNb2" would be named "EpfuNb2SimResidPlot").
#'
#' @seealso \code{\link{ResidPlotLong}}
#'
#' @examples
#' data("BatDataWide", "EpfuNb2Wide", "MyevNb2Wide", package = "EcoCountHelper")
#' 
#' ResidPlotWide(BatDataWide, c("EpfuNb2Wide", "MyevNb2Wide"), "^[[:alpha:]]{4}")
#' 
#' EpfuNb2WideResidTests
#' EpfuNb2WideSimResidPlot
#' MyevNb2WideResidTests
#' MyevNb2WideSimResidPlot
#'
#' @export

ResidPlotWide <- function(Data, ModNames, GroupPat = "^[[:alnum:]]+",
                         Nsims = 1000, TestVals = T){

  ResidPlotterSub <- function(GroupMod){
    TmpMod <- get(Filter(function(x) inherits(get(x), "glmmTMB"), ls(pattern = GroupMod,
                                                                     pos = .GlobalEnv)), pos = .GlobalEnv)
    Group <- regmatches(GroupMod, regexpr(GroupPat, GroupMod))

    ModTab <- stats::simulate(TmpMod, nsim = Nsims)
    SimMod <- do.call(cbind, ModTab)
    SimModDharma <- DHARMa::createDHARMa(simulatedResponse = SimMod, observedResponse = Data[[Group]],
                                 fittedPredictedResponse = predict(TmpMod), integerResponse = TRUE)
    GroupResidTests <- DHARMa::testResiduals(SimModDharma)

    title(sub = GroupMod, font.sub = 2)
    ResidPlot <- grDevices::recordPlot()
    assign(paste0(GroupMod, "SimResidPlot"), ResidPlot, pos = .GlobalEnv)
    if(TestVals == T){assign(paste0(GroupMod, "ResidTests"), GroupResidTests, pos = .GlobalEnv)}
  }
  lapply(ModNames, ResidPlotterSub)
}
